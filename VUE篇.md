## VUE篇

1.MVC 和 MVVM 的不同：MVC 里面的数据模型能够直接渲染到视图上面去，也能通过 Controller 渲染上去，并且在 Controller 中需要手动操作html；而 MVVM 里面的数据只能通过 view-model 与视图进行交互，view-model 作为中间层，核心是双向绑定，不需要人们手动操作 html。

2.Vue 的单向数据流：Vue 的 prop 只能从父级流向子级，而并不能从子级流向父级，这样会防止子级意外改变父级组件的状态，从而导致数据的变化难以理解。

3.双向绑定是指通过修改数据，可以自动实现视图的修改；通过操作视图，又可以反过来自动实现数据的修改。

4.Vue 如何实现双向绑定：Vue 是通过数据劫持和事件来实现双向绑定的，通过劫持数据的 getter 来收集订阅者，通过劫持数据的 setter 来对订阅者进行更新，这样就实现了在数据变动的时候改变视图；然后在操作视图的时候，触发事件，通过事件的回调来改变数据。

5.Vue 如果劫持数组：1.对要监测的数组，拦截它的常用方法，比如splice、push、pop等。2.对于数组单个元素的修改提供$set这个 api。3.遍历数组的元素，如果是对象或者是数组的话，就继续监听。

6.Vue 各生命周期做的事：

```
1.初始化生命周期：初始化父子节点，和各种生命周期flag
2.初始化事件：初始化父节点挂载到它上面的各种事件
3.初始化render相关：挂载createElement，把slot的vnode变成slot对象，添加响应式的 $attrs 和 $listeners
4.=================执行 beforeCreate 钩子========================
5.添加响应式的 injections
6.初始化状态：初始化props、data、compute、watch、methods
7.初始化 provide 属性
8.=================执行 created 钩子=================
9.判断el是否存在，是则调用暴露出来的 $mount 方法（runtime、服务端渲染、非runtime、weex有各自的实现），否则表示是一个组件，等组件自己调用 $mount 方法
10.判断 template 是否存在（不存在的话就去拿 el 的 html），然后编译 template（先编译成 ast 树，然后对静态节点进行优化，最后生成 render 函数代码）
11.=================执行 beforeMount 钩子=================
12.使用 render 函数创建 vnode
13.使用 update 函数把 vnode 生成 $el，并且进行挂载
14.对 vm 建立一个 watcher，当变动的时候，使用 update 方法进行更新
15.=================执行 mounted 钩子=================
16.如果有数据变动
17.=================执行 beforeUpdate 钩子=================
18.使用 update 方法进行更新，并进行 patch
19.=================执行 updated 钩子=================
20.如果开始卸载
21.=================执行 beforeDestroy 钩子=================
22.卸载子组件
23.卸载 watchers、event listeners
24.=================执行 destroyed 钩子=================
```

7.diff算法的理解：

```
比较相同节点下的子节点：
1.先查看有没有相同并且不需要移动的节点，这些节点不需要变动
2.然后查看有没有相同但是需要移动的节点，这部分节点进行简单的移动即可
3.最后对那些没有的旧节点进行删除，对那些没有的新节点进行新增
```

8.
