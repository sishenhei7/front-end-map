## 概述

最近在看算法红宝书，把心得记录下来，供以后开发时参考，相信对其他人也有用。

## 基础

### 基础编程模型

1.在计算机科学领域，我们用算法这个词来描述一种有限、确定、有效的并适合用计算机程序来实现的解决问题的方法。

2.学习算法的主要原因是它们能节约非常多的资源，甚至能够让我们完成一些本不可能完成的任务。

3.现代大多数语言都共有这几种语法：原始数据类型（整数、浮点数、布尔值等）、语句（声明、赋值、条件、循环、调用、返回）、数组、静态方法、字符串、标准输入输出、数据抽象。

4.说到原始数据类型，与之相关的是表达式，表达式又有优先级；类型转换；比较；其它原始类型。

5.对于语句，我们有很多简便记法：声明和赋值结合起来（声明初始化）、隐式赋值、单语句代码段。

6.数组能够顺序的储存相同类型的多个数据，除了储存数据，我们也希望能够访问数据，访问数组中的某个元素的方法是将其编号然后索引。

7.下面是比较典型的数组处理代码：

```js
// 找出数组的最大元素
const max = Math.max(...a)

// 计算数组元素的平均值
const average = a.reduce((a, b) => a + b) / a.length

// 复制数组
const b = [...a]

// 颠倒数组元素的顺序
const c = a.reverse()

// 方阵相乘
let c = 0;
for(let i = 0; i < N; i++) {
    for(let j = 0; j < N; j++) {
        for (let k = 0; k < N; k++) {
            c += a[i][j] * b[j][k];
        }
    }
}
```

8.数组有一个重要的性质是起别名。

9.编写递归代码时最重要的有这三点：总有一个最简单的情况（第一条语句总是包含return的条件语句）；总是去尝试解决一个规模更小的子问题；父问题和子问题之间不应该有交集。使用递归的另一个原因是我们可以使用数学模型来评估程序的性能。

10.模块化编程的一个重要组成部分就是记录库方法的用法并供其他人参考的文档。我们统一使用应用程序编程接口的方式列出本书中使用的每个库方法名称、签名和简短的描述。

11.API 的目的是将调用和实现分离。相应的，程序员也可以将 API 看做调用和实现之间的一份契约，它详细的说明了每个方法的作用。既然分为调用和实现，那么有一个先后的问题，如果先做实现再做怎么调用的话，所做的事就和一个搬瓦工差不多，搬砖（做实现）完成之后做一个总结（做调用）；但是如果先做怎么调用再做实现的话，所做的事就和架构师一样了。

12.说到字符串，就有字符串拼接、类型转换、自动转换和命令行参数。

13.我们使用数据抽象有这几个原因：它允许我们通过模块化编程复用代码；它使我们可以轻易构造出多种所谓的链式数据结构；借助它我们可以准确定义所面对的算法问题。

14.在 Java 中，一个静态方法不能将另一个静态方法作为参数，但是在其它很多语言中，这是可以的。

15.为什么 if 语句中会有大括号，是为了避免下面这种歧义情况：

```
if <expr1> if <expr2> <stmntA> else <stmntB>

if <expr1> { if <expr2> <stmntA> else <stmntB> }

if <expr1> { if <expr2> <stmntA> } else <stmntB>
```

16.js 里面是没有元组的，但是我们可以使用按位异或和左移这2个位运算来实现多元组的状态变更：

```js
// 比如一个四元组的状态切换
// 初始状态
let a = 0;

// 切换第一个状态
a ^= (1 << 0)

// 切换第二个状态
a ^= (1 << 1)

// 切换第三个状态
a ^= (1 << 2)

// 切换第四个状态
a ^= (1 << 3)

// 依次切换 三、一、四、二、一、三 状态后 a 等于 10
a = 0
a ^= (1 << 2)
a ^= (1 << 0)
a ^= (1 << 3)
a ^= (1 << 1)
a ^= (1 << 0)
a ^= (1 << 2)


// 依次切换 二、四 状态后 a 也等于 10
a = 0
a ^= (1 << 1)
a ^= (1 << 3)
```

### 数据抽象

17.定义和使用数据类型的过程被称为数据抽象。抽象数据类型的不同之处在于它将数据和函数的实现关联，并将数据的表示形式隐藏起来。在使用抽象数据类型时，我们的注意力集中在 API描述的操作上而不会去关心数据的表示；在实现抽象数据类型时，我们的注意力集中在数据本身并将实现对改数据的各种操作。

18.子类继承阻碍模块化编程的原因有两点：父类的任何改动都会影响它的所有子类；子类代码可以访问所有实例变量，因此它们可能会扭曲父类代码的意图。（这2点在 javascript 中都被避免了）

19.弃用（deprecated）的方法指的是不再被支持但为了保持兼容性而留在 API 中的方法。


### 背包、队列和栈

20.数据类型的值就是一组对象的集合，所有操作都是关于添加、删除或是访问集合中的对象。

21.对于许多应用场景，用例的要求只是用某种方式处理集合中的每个元素，或者叫迭代访问集合中的所有元素。

22.背包是一种不支持从中删除元素的集合类型——它的目的就是帮助用例收集元素并迭代遍历所有收集到的元素（用例也可以检查背包是否为空或者获取背包中的数量）

23.在应用程序中使用队列的主要原因是在用集合保存元素的同时保存它们的相对顺序。

24.一个可迭代的集合数据类型中我们需要实现：1.一个```iterator()```方法并返回一个```Iterator```对象。2.```Iterator```对象必须包含2个方法：```hasNext()```和```next()```。

25.数组在初始化之后不能改变大小，这个它很严重的缺陷，但是链表可以。（js中的数组是用链表实现的）

26.链表是一个递归的数据结构，它或者为空(null)，或者是指向一个节点(node)的引用，该节点含有一个泛型的元素和一个指向另一条链表的引用。

27.单向链表有2个致命的性能缺陷就是：1.删除指定的节点。2.在指定节点前插入一个新节点。为了解决这个问题，我们发明了双向链表，它是实现任意插入和删除操作的标准解决方案。

28.链表在增删方面很高效，数组在寻址方面有优势。

29.数组支持随机访问，查找时间复杂度为1，插入和删除的时间复杂度为n；链表的查找时间复杂度为n，插入和删除的时间复杂度为1；散列表的查找、插入和删除的时间复杂度都是1-n。

30.既然有了链表，为什么还要学习调整数组的大小？我们还会学习若干抽象数据类型的示例实现，它们需要使用数组来实现一些链表难以实现的操作。resize是控制它们的内存使用的样板。

31.数组和链表是最基础的数据结构，它们被称为顺序储存和链式储存。这种链式储存的一个扩展是二叉树；而另一个扩展式复合型的数据结构，比如用背包储存栈，用队列储存数组，用数组的背包表示图等。

### 算法分析

32.一个程序运行的总时间主要和两点有关：执行每条语句的耗时；执行每条语句的频率。

33.设T(N)为 ThreeSum 处理 N 个整数的运行时间，根据前文所述的数学模型有 T(N) 近似为 aN^3，其中常熟a取决于计算机的具体型号。

34.对于大多数程序，得到它的运行时间的数学模型的是：1.确定输入模型，定义问题的规模；2.识别内循环；3.根据内循环中的操作确定成本模型；4.对于给定的输入，判断这些操作的执行频率。

35.随着问题规模的扩大，算法增长数量级的比例并不是和一个常数，而是2^b(倍率定理)

36.算法还可以评估使用更快的计算机所产生的的价值。

### union-find 算法

下面是我自己写的 union-find 算法的 js 版本。

```js
class QuickFind {
  constructor(count) {
    this.list = Array(count).fill(0);
    this.count = count;
  }

  count() {
    return this.count;
  }

  find(p) {
    return this.list(p);
  }

  // 把 p 的分量归并到 q 的分量重
  union(p, q) {
    const pID = this.find(p);
    const qID = this.find(q);

    if (pID === qID) return;

    for(let i = 0; i < this.list.length; i++) {
      if (this.list[i] === pID) this.list[i] = qID;
    }

    this.count--;
  }

  connected(p, q) {
    return this.find(p) === this.find(q);
  }
}

class QuickUnion {
  constructor(count) {
    this.list = Array(count).fill(0);
    this.count = count;
  }

  count() {
    return this.count;
  }

  // 找到 p 的 root节点
  find(p) {
    let item = p;

    while (item !== this.list[item]) item = this.list[item];

    return item;
  }

  // 把 p 的分量归并到 q 的分量重
  union(p, q) {
    const pRoot = this.find(p);
    const qRoot = this.find(q);

    if (pRoot === qRoot) return;

    id[pRoot] = qroot;
    this.count--;
  }

  connected(p, q) {
    return this.find(p) === this.find(q);
  }
}

class WeightedQuickUnion {
  constructor(count) {
    this.list = Array(count).fill(0);
    this.count = count;
    this.weight = Array(count).fill(1);
  }

  count() {
    return this.count;
  }

  // 找到 p 的 root节点
  find(p) {
    let item = p;

    while (item !== this.list[item]) item = this.list[item];

    return item;
  }

  // 把 p 的分量归并到 q 的分量重
  union(p, q) {
    const pRoot = this.find(p);
    const qRoot = this.find(q);

    if (pRoot === qRoot) return;

    if (this.weight[p] > this.weight[q]) {
      this.list[qRoot] = pRoot;
      this.weight[pRoot] += this.weight[qRoot];
    } else {
      this.list[pRoot] = qRoot;
      this.weight[qRoot] += this.weight[pRoot];
    }

    this.count--;
  }

  connected(p, q) {
    return this.find(p) === this.find(q);
  }
}
```






