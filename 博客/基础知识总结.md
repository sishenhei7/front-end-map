## 概述

总结下基础知识。

### 自我介绍

你好，很荣幸能够参加这次面试。我叫杨舟，毕业于西南交通大学应用数学专业。之前在一面数据负责公司对内和对外产品的前端开发工作。我开发的主要项目是 YiDrone 和 公司官网，在 YiDrone 中我使用 Echarts 对数据进行处理和各种可视化展示，帮助用户洞察市场方向。在公司官网里面我使用 Nuxt 框架进行服务端渲染，以便于SEO和首屏渲染。

在工作的时候，我非常注意所写代码的可读性和严谨性，也会积极推动和把控项目进度。由于我上一家公司的重心不在产品开发这一块，产品开发团队比较小，流程不是很规范，所以我选择出来谋求更好的发展。贵公司是个很大技术也很强的公司，无论是公司的技术，人，还是产品我都很想进去看一看，希望能给我这个机会。

我是通过拉勾网了解到贵公司也是做toB业务的，而且招聘信息里面的code review也让我眼前一亮，希望能够进入贵公司发展。


针对hr:

您好，很荣幸能够参加这次面试。我叫杨舟，毕业于西南交通大学应用数学专业。毕业后在银汉科技有限公司担任数值策划，后来转行前端，在广州魔笛科技公司做Web前端开发，主要是给网易做一些外包性质的网页，同时也会做一些H5独立项目，然后在深圳一面数据做前端开发，负责公司对内和对外的产品开发工作，比如公司的主要产品Yidrone、公司官网、生意参谋Chrome插件等等。现在大家都推崇科技赋能，平安hrx把科技着眼于人力化系统，让我很感兴趣，希望能给我一个加入的机会。

hrx是智慧人力化部门，主要做一些平安和政府、大型企事业单位的智慧化人力系统。

为什么转行前端：第一个是做游戏要把握玩家心理，让玩家充钱，让我有罪恶感。第二个是我们需要每天玩不同的游戏，借鉴它们的玩法，让我不踏实，我感觉我还是适合做一些技术方面的工作。而前端那种所见即所得的技术，就是你在浏览器上面更改一下代码，然后就能立刻在浏览器上面看见不同的显示，这个让我很兴奋。

那么长时间是在干嘛：本来我是希望朝着数据挖掘方面发展的，然后我去看了一些关于数据挖掘的书，包括一些英文书籍，还参加了网上的数据挖掘比赛，后来在面试的时候发现这个行业门槛很高，需要硕士学历，然后需要有一个好的导师，才能有好的算法和数据挖掘能力。所以后来就转行前端了。

为了转行前端你做了些什么：首先去看前端方面的书打基础，比如js红宝书、css世界等等，然后去参加网上的百度前端技术学院增强自己的动手能力，再就是准备一些作品，当时为了求职我用react写了一个博客。

为什么离职广州魔笛：当时魔笛的老大很好，但是公司毕竟是做外包的，用的前端技术有点过时了，我想学习并使用更加新的前端技术，就离职去了一面数据。

为什么离职一面数据：因为一面数据主要是做数据分析和商业咨询的，公司的重心在爬虫抓取数据和数据分析那块，并不在产品开发这块，产品开发团队也很小，没有充足的资源和机会尝试新技术，就离职寻找更好的机会了。

职业规划：首先是做好自己的份内工作，尽快上手业务，然后公司前端这边有 vue 和 react 两种技术栈，我自己是 vue 的，所以我会尝试学习 react，这样能更好的和其他部门的人沟通和做技术分享。

怎么看待加班的：放太多假会让人变懒散，加班能提醒自己不断奋斗。

有没有期望薪资：我相信平安这边会根据我表现出来的能力和岗位的薪酬预算给出合理的薪资

有没有想问的：有哪些项目组，我会在哪个项目组？

你有什么优点和缺点：我的优点是喜欢尝试新技术，缺点是和人说话的时候会不由自主的有些紧张，特别是在很多人面前说话的时候。





YiDrone 里面出彩的点：
1.支持搜索、多选的级联选择器
2.echarts图表的各种可视化调整（纵坐标显示整数）
3.通过watch数据的响应来进行局部刷新
4.页面初始化数据的方法

yidrone里面出彩的点：
1.选择器
2.echarts的自定义配置
3.小程序登录
4.移动端tooltip

官网里面出彩的点：
1.后台登录
2.各个组件
3.编辑器
4.分享功能

生意参谋
1.加解密






Nuxt 官网里面出彩的点：
1.当初选型的时候尝试过各种方向，比如自己按照尤大的示例来搭建服务端渲染，但是打包的处理可能没有 vue-cli 那么精细，而且维护起来也很耗费时间；于是我就又尝试改造 vue-cli，打算结合 vue-cli 来进行服务端渲染，但是会出现各种奇怪的 bug，也不知道以后会不会出现其他 bug；最后才选择了 nuxt，它对各种打包的支持还算全面，也能支持一些自定义的修改，文档里面还有关于部署等的说明，还算挺方便的
2.开发的过程中就比较顺利了，按照文档来就行了，但是有一个问题就是怎么做登录。我们所有产品都是用session保存登录token的，没有用cookie，用session的问题就是，在第一个请求的时候，nuxt服务器获取不到浏览器 session 里面的 token，所以在第一次打开页面的时候无法自动登录。为了解决这个问题，我去看了 nuxt 官方的登录 demo，还有其他 nuxt 应用的源码，它们都是用的 cookie。所以我只能自己想解决方案了，最后我用了一个中转路由来专门进行自动登录成功解决了，但是有一个缺点就是开始会有一小段时间的白屏，但是可以接受
3.最后后台需要使用编辑器，有很多编辑器可以选择了，最后我选择了ckeditor5，这个编辑器界面比较漂亮，也支持自定义一些组件，为此我给公司官网专门写了一个ckeditor5的自定义组件库

业务上：这个项目的业务背景是什么，在业务上有什么比较牛逼的地方，推动了业务如何运行等等
技术实现上：这个项目的整体技术实现思路是怎样的，项目中用了什么比较牛逼的技术，解决了什么比较困难的问题等等
这个项目做了什么牛逼的事情
你在项目里做了什么牛逼的事情
用了什么牛逼的技术解决了什么困难的问题

yidrone
1.项目中 pm 需要在顶部加上一个级联选择器，需要支持搜索，多选等需求，使用 element 实现不了，所以当时我自己写了一个。最开始的时候，我没有使用面向对象的设计方法，而是直接分成2个模块：显示面板和输入框，然后写这2个模块的逻辑，并且所有的代码都是命令式的，比如点击一个面板数据，我就命令式去把相应数据筛选出来，展示在下一个面板里面去。这样写完，各种数据糅合在一起，很难管理，出错的时候也很难定位问题。后来我去查看 element 的级联选择器源码，发现它使用了面向对象的写法，额外抽离出一个 node 类来表示面板里面的每一行数据，并且抽离出 store 类来对 node 进行各种操作。于是我也学习这种方法，使用 node 类来作为面板每一行的数据结构，然后在它上面一层使用 store 来抽离出业务逻辑，最后就只需要 ui 组件进行展示就可以了。使用这种封装，使得 node 类可以响应式的自己完成各种状态显示，而且业务报错可以很方便的在store.js里面查找原因，后期如果增加业务逻辑的话，也只需在 store 里面增加相应代码即可。
2.项目有一个移动端，是通过媒体查询，修改 css 进行兼容的。但是 element 的组件并不是为移动端设计的，所以有一些bug，其中最明显的是，tooltip组件在移动端的时候就需要再次点击的时候才消失，不会在滑动的时候消失，那当时我去查看 tooltip 的源码，对 element 的 tooltip 进行封装，监听 touchmove事件，让用户在滑动的时候tooltip能够消失。
3.全是四位数就用k做单位。

官网
瀑布流问题、滑到某个点开始播放动画、图片分享问题。

生意参谋插件
我们的数据分析组需要对生意参谋进行取数，于是去求助爬虫组希望能够直接把需要的数据爬下来，但是生意参谋的反爬技术做的太好了，根本爬不了数据。于是来向我们产品研发组求助，希望能开发一个chrome插件能够取数。前端本身就没有加密，因为所有的代码包都能够获取到，只是被压缩混淆了而已。所以我就去调研这个任务，去查看生意参谋的混淆之后的代码，当时我对前端加密技术不怎么熟，看了好久也没什么进展，很难看出它的加密代码放在哪里。后来我发现市面上有很多收费的生意参谋插件，于是我去查看它们的代码，很多插件加了debug保护，在debug的时候会运行一段循环代码耗尽内存导致死机。最后我找到一个加密没做这么严格的插件，它的解密代码被我找到了，于是我相当于能查看它的所有源码了。我查看它的源码获取它的解密方式，并且知道它是通过获取 localstorage 和 拦截 fetch 请求来获取数据的。我利用这些信息，按照数据分析组的需求，做了这个插件。虽然整个过程不怎么光彩，但是能够解决问题，并且我从中也学到了一些前端加密技术。


### 事件冒泡

事件捕获：先触发父元素的监听事件，再触发子元素的监听事件
事件冒泡：先触发子元素的监听事件，再触发父元素的监听事件
我们可以用 stopPropagation 阻止事件传播，在 Vue 里面可以用 stop 修饰符阻止事件传播

### 闭包

闭包就是定义在一个函数内部的函数，它在外部函数被回收后仍然能够读取外部函数里面的局部变量。（因为是储存在堆里面）

### Vue 的双向绑定原理

Vue 使用 Object.defineProperty 来劫持数据的 getter 和 setter 方法，当触发getter的时候收集订阅者或者说依赖，当触发setter的时候对订阅者进行更新。

所以我们可以在视图上面通过各种方法给数据赋值，也能够在改变数据的时候触发setter方法进行视图更新。

### 箭头函数的理解

js里面有一个机制叫做变量提升，就是 var 和 function 在编译前都会先提升到顶部，这通常会带来一些意想不到的bug。为了解决这个问题，es6对于var提出了const 和 let，对于function则提出了箭头函数。箭头函数有一个特性就是他会捕获外部作用域里面的this当做自己的this。

### 前端路由原理

前端路由有2种，一种是hash路由，另一种是history路由。hash路由的原理是改变路由的hash值，浏览器不会刷新，然后前端通过监听hash值的改变来对应用进行各种变化；history路由是利用html5的history api实现的，这个api提供了一些方法使得改变路由的时候不会刷新浏览器。

### Vue中data为什么是函数

这其实是一个工厂函数，为了在每次使用这个 vue 组件新建实例的data互不共享。

### 线程与进程

没有过多的了解。只知道它们都是程序执行的单位，其中一个进程可以有多个线程。

### BOM与DOM

DOM Document Object Model 是 W3C 的标准，所有浏览器共同遵守
BOM Browser Object Model 是各个浏览器上面的实现

### 性能优化相关

减少网络请求
避免回流和重绘
使用缓存
雪碧图
代码混淆、压缩，GZIP压缩
防抖和节流

工程方面：
1.按需加载
2.css purge 不引入没用到的 css
3.部分页面动态加载
4.防抖和节流（后端搜索，频繁触发的事件）

### 缓存相关的http头部属性

### microtask 和 macrotask

### 你对Vue的理解有多少

### 讲述一下计算机网络的七层

物理层，数据链路层，网络层，传输层，会话层，表示层，应用层

### TCP和UDP

### HTTPS是什么

是指用ssl或tls加密的http，它使用证书和数字签名来验证身份，可以用lets encrypt很简便的把http变成https

### http 和 https 有什么区别

1.端口不同，http是80端口，https 是443端口
2.加密不同，http是明文传输；https是ssl、tls加密传输
3.https的证书需要申请，还有过期时间

### 介绍几种常见的状态码

200 请求成功
301 重定向
401 身份需要验证
500 服务器错误

### 如何跨域

jsonp
反向代理
cors
postmessage

iframe

### 进程和线程是什么

### 死锁是什么

### Left Join、Right Join、Inner Join 指的是什么

### 精确获取页面元素位置的方式有哪些

getBoundingRect

### new一个对象过程发生了什么

1.创建一个对象
2.把this指向这个对象
3.初始化里面的属性和方法

### 如何编写代码实现构造函数不用new关键字会报错

function Haha() {
    if (!(this instanceof Haha)) {
        throw new Error('报错');
    }
}

### 从输入 URL 到页面加载完成，发生了什么？

1.浏览器查看是否缓存
2.浏览器构建 http 请求
3.浏览器查看 dns 缓存看有没有相应的 ip 地址
4.浏览器通过 dns 查找对应的 ip 地址，
5.然后发送 http 请求，进行三次握手
6.接收 http 请求，进行四次挥手
7.进行浏览器渲染
8.用正则处理 html 标记，构建 dom 树
9.处理样式，构建渲染树
10.最后渲染到屏幕上

### wepack4 有什么新特性

1.零配置，可以不使用 webpack.config.js 就打包
2.各种配置升级和 loader 升级，内置了一些 loader，并删除了一些 loader

### webpack 性能优化

1.webpack-burdle-analysis查看打包的代码中各模块的大小
2.使用 code-splitting 分离公共代码，抽出css代码分开打包（方便同时加载）
3.使用 sideEffects 设置来进行 tree shaking
4.设置webpack的css query，在移动端和pc端加载不同的css文件
5.懒加载，设置部分库在用到的时候再加载
6.按需加载，比如设置 element 的按需加载
7.css purge 进行按需引入 css 库，比如 taiwind 库

### http1.0，http1.1, http2.0的特性

http1.0 是无状态、无连接的应用层协议，使用cookie、session来处理登录
http1.1 长连接，connection: keep-alive；管道化的，强缓存和协商缓存；断点传输
http2.0 多路复用(连接共享)(二进制分帧)，服务器推送，头部压缩

### 什么是类数组，和数组的区别

类数组是有length属性的对象，并且它的属性为非负整数
1.Array.from()
2.[...item]
3.Array.prototype.slice.call()

### document.ready和window.onload的区别

ready是加载完dom树之后执行，不包括图片等
onload是全部加载完成之后执行，包括图片

### 什么是渐进式图片

渐进式图片是一种图片格式，他会先加载图片轮廓，等图片完全加载之后再显示清晰图片。非常吃内存和cpu

### vue3.0 为什么使用 proxy ？

1.Object.defineProperty 不能监听数组，所以要劫持push等方法
2.Object.defineProperty 只能监听属性，所以要深度遍历

### vue 父子组件如何传值

1.使用 props 和 events
2.通过 v-model
3.通过 sync
4.通过 $children 和 $parent 属性
5.使用 ref
6.通过 inject 和 provide
7.使用 vuex
8.使用 event-bus
9.自己手写一个简单地 store
10.还可以用 url 上面的参数来进行传值

### 说下 diff

1.首先为了提高效率，vue 仿照浏览器对节点使用 vnode 进行表示，只不过 vnode 里面比浏览器的节点对象里面的属性少得多，这样能提高性能。
2.然后，vue 的 diff 只针对相同节点下的子节点，diff 的流程是这样的
3.首先查看有没有相同并且不需要移动的节点，这部分节点不需要变动
4.然后查看有没有相同节点但是需要移动的，这部分节点进行简单的移动即可
5.最后对于那些没有的旧节点进行删除，没有的新节点进行新增
6.比较完成之后，针对 vnode 比较结果，在实际 dom 上执行相应的操作

### diff 怎么判断 sameVnode

1.判断 key
2.判断 tag
3.判断 comment, data 等属性

### vue 和 react 的区别

相同点：

1.都使用了 virtual dom
2.都提供了响应式的和组件化的视图组件
3.都将注意力保持在核心库，而将其他功能比如路由交给相关的库

不同点：

1.react 里面有 shouldComponentUpdate，相反，vue 不能配置 是否更新。
2.react 的思想是一切都是 js，推荐使用 css in js。vue 拥抱经典的 web 技术，让人有亲切感
3.react 的学习曲线很陡峭，vue 由于拥抱经典的 web 技术，很容易上手
4.vue 的一些库比如路由库和状态管理库交给官方维护，而 react 都把它们交给社区维护，所以 react 的社区更加繁荣一点
5.它们的 cli 工具：vue-cli 和 create-react-app 具有不同的设计理念，这就导致 vue-cli 能够在外部修改配置，而created-react-app不推荐在外部修改配置。

### 首屏优化

1.把background-image里面的图片进行预加载
2.把 css 和 js 内嵌到html里面去
3.把必要的js数据提前
4.使用占位图片，placeholder ui
5.使用lighthouse查看首屏渲染情况

### 手撕一个 Emitter 类的代码：

```
class Emitter {
    constructor() {
        this.events = {};
    }

    emit(eventName, ...params) {
        const callbackList = this.events[eventName] || [];
        callbackList.forEach(cb => cb.call(this, ...params));
        return this;
    }

    on(eventName, callback) {
        if (!this.events[eventName]) {
            this.events[eventName] = [];
        }

        this.events[eventName].push(callback);
        return this;
    }

    once(eventName, callback) {
        const temp = (...params) => {
            callback.call(...params);
            this.off(eventName, temp);
        }

        this.on(eventName, temp);
        return this;
    }

    off(eventName, callback) {
        const callbackList = this.events[eventName];
        this.events[eventName] = callbackList && callbackList.filter(cb => cb !== callback);
        return this;
    }
}
```

面腾讯灯塔的收获：

1.项目中棘手的事情和怎么解决的。
2.webpack 配置和优化
3.react 和 vue 的区别
4.组件间通信
5.vue 的 diff 算法深入理解
6.vuex 的 mutation 和 action 的区别
7.多路复用

（没有问网络基础，没有问算法，没有问后端）

字节跳动一面的收获：

1.强缓存和协商缓存

字节跳动二面的收获：

1.算法能力很差
2.webpack 不熟
3.vue 的原理不熟
4.js 的一些特性不熟，比如 xhr 等
5.后端能力不是很强
6.意识到最近写博文少了，对一些原理性的东西没有深入研究

ones 一面的收获：

1.对算法还是不了解
2.要开始看各个库的实现原理(比如说 ckeditor 这个插件是怎么初始化的)


```js
function singlePipe(promiseFunc) {
    // todo
    let isResolved = true;

    return function (num) {
        if (isResolved) {
            isResolved = false;
            return promiseFunc(num).then((res) => {
                isResolved = true;
                return res;
            });
        }

        return Promise.reject('not resolved');
    }
}
var promiseFunc = function (data) {
    return new Promise((resolve) => {
        window.setTimeout(() => resolve(data), 1000);
    });
};

var request = singlePipe(promiseFunc);
request(1).then(data => console.log(data)); // 1
request(2).then(data => console.log(data)); // 无反应
window.setTimeout(() => {
    request(3).then(data => console.log(data)); // 3
}, 1000);
```

团队的规模，有哪些人，对团队的规划，如果入职的话，负责什么内容。


