## http篇

### http2.0 协议

历史：

```
http/1.0：每次请求都需要建立一个新的 tcp 连接

http/1.1：可以持久连接，但是必须先进先出（浏览器有并发限制，一般是 6 个，同时这个也防止了 ddos 攻击）
```

首部压缩：

```
目标：为了减少传输流量

条件：两端维护相同的静态字典和动态字典，并且都支持静态哈夫曼表的哈夫曼编码

原理：完全匹配的键值对直接用字典的key；只匹配到头部信息，可以用一个字符+哈夫曼编码；浏览器可以告知服务器往动态字典里面添加头部信息
```

二进制分帧：

```
目标：在高层 http api 与低层 tcp 之间引入二进制分帧层，一个请求报文会被分割成多个帧。

原理：tcp 连接在客户端、服务端建立双向通道；A端将消息切割成多个帧；A端发起一个流，并在流中将多个帧传输到B端，B端把多个帧整合成消息。
```

多路复用：

```
目标：在一个 tcp 连接可以并发多个请求和响应

原理：二进制分帧的帧具有流ID，接收端可以根据ID整合帧，这样可以无序并发的发送多个流的帧。

注意：由于可以并发和木桶效应，影响传输的瓶颈在于体积最大的那个帧。
```

服务器推送

```
目标：服务器拥有主动推送资源的能力

原理：服务器在响应请求的时候，可以主动推送一些其他的资源。

注意点：需要有请求才能有推送；服务器推送只是减少了客户端的对推送资源的请求
```

优先级与依赖性

```
目标：由于 http2.0 可以并发多个请求和响应，这些资源又有重要性的区别，所以需要制定这些资源的优先级
```

### udp 协议

```
定义：面向报文的简单协议

特点：无连接的；可以一对多；尽最大努力交付，不保证可靠；传输效率高

应用场景：包总量很少的通信：DNS；视频音频即时通信；广播

与tcp的区别：tcp是面向连接的，只能一对一，保证可靠，传输效率低
```

### tcp、ip网络分层

```
定义：分为应用层，传输层，网络层和数据链路层

应用层：决定了向用户提供何种服务，常见协议有http、ftp、dns
传输层：对应用层提供数据传输，常见协议有tcp、udp
网络层：用来处理网络上的数据包，规定了传输路线和怎么样把数据包传送给对方
数据链路层：硬件
```

### osi 七层网络模型

```
全称：Open System Interconnection Reference Model

历史：当时符合tcp、ip网络分层的协议很多、很混乱

定义：应用层，表示层，会话层，传输层，网络层，数据链路层，物理层

应用层：面向具体的应用传输数据
表示层：把数据转换成合适、可理解的语法
会话层：维护网络中的连接状态
传输层：相当于tcp/ip里面的传输层
网络层：相当于tcp/ip里面的网络层
数据链路层：相当于tcp/ip里面的数据链路层
物理层：网络的物理形式，比如电缆、光纤等
```

### cdn

```
定义：Context Delivery Network，应用了 http 协议里的缓存和代理技术，代理源站响应客户端的请求。是一种专门解决长距离网络传输慢这个问题的网络应用服务。

核心原则：就近原则

使用的技术：缓存代理，负载均衡
```

### web 服务器

```
硬件含义：物理形式或云形式的物理机器，可能不是一台服务器，而是一个集群。

软件含义：提供 Web 服务的应用程序
```

### url 和 uri

```
差异： url 是 uri 的一个子集

构成部分：协议名 + 主机名 + 路径
```

### 代理

```
定义：执行转发的服务器

匿名代理：隐匿了的代理服务器
透明代理：外界既知道代理，也知道服务器
正向代理：靠近客户端
反向代理：靠近服务器

用途：负载均衡、内容缓存、安全防护、数据处理
```

### https 协议

```
定义：本质上还是 http 协议，只不过把下层的 tcp/ip 协议换成了 ssl/tls
```

对称加密：

```
定义：加密和解密用的是同一个秘钥，速度很快

算法：AES，ChaCha20

分组模式：把秘钥加密成任意长度的密文，比如：GCM，CCM，Poly1305

定义：把算法和分组模式结合起来，就是对称加密，比如 AES128-GCM 表示秘钥长度为 128 位 AES 算法，并且分组模式为 GCM 的对称加密方法
```

非对称加密：

```
定义：加密和解密用的是不同秘钥，速度不快

例子：DH、DSA、RSA、ECC

RSA：最著名的一个，基于因素分解的数学难题

ECC：是后起之秀，基于椭圆曲线离散对数的数学难题
```

混合加密：

```
起因：需要速度快又安全的加密方式

定义：在通信刚开始的时候使用非对称加密，解决秘钥交换问题，之后使用对称加密进行信息传输
```

完整性：

```
定义：指数据在传输过程中没有被篡改。

算法：摘要算法，比如散列函数、哈希函数

原理：把任意长度的数据加密成任意长度并且独一无二的摘要字符串

特点：单向不可逆推，雪崩效应

哈希消息认证码（HMAC）：摘要算法并不保证机密性，所以在混合加密里面同时加密消息和摘要，它主要运用于身份认证中
```

数字签名：

```
定义：是私钥对摘要的加密，只能由私钥对应的公钥解密，实现身份认证。
```

数字证书：

```
目标：解决公钥的信任问题。（因为数字签名里面的公钥容易被替换）

过程：由 CA 把公钥、序列号、用途、颁发者、有效时间打成一个包再进行签名，就形成了数字证书

用途：用来在非对称加密中确认服务器的真实性
```

中间人攻击：

```
定义：中间人产生一对非对称秘钥，然后代替假装服务器发布公钥给客户端

怎么避免中间人攻击：使用数字证书证明公钥是服务器的公钥

数字证书所需的 CA 公钥怎么认证：内置在浏览器或操作系统中
```

### 跨域

同源策略：

```
定义：协议、域名、端口三者必须相同

限制内容：Cookie、Storage、DOM 节点、Ajax 等
```

解决方案：

```
图像ping: 利用了 img src标签没有跨域限制的漏洞

jsonp：利用了script标签没有跨域限制的漏洞

cors：跨域解决方案，前端不需要做什么，需要后端配置 cors。（cors请求会分为简单请求和非简单请求，简单请求的话浏览器会自动加上Access-Control-Allow-Origin-xx 头部，非简单请求会在通信之前增加一次 http 查询请求）

websocket: 使用 ws

node、nginx等代理：服务器没有同源策略

postmessage：主要用于页面之间的通信，页面的所属域不同
```

什么是cors: 跨域资源共享，允许浏览器向跨域服务器发出 http 请求，从而克服跨域问题。

```
1.浏览器会自动向请求添加 origin 字段，表明当前请求来源
2.服务器端需要设置响应头：access-control-allow-methods、access-control-allow-headers、access-control-allow-origin字段，指定允许的方法、头部、源等信息
```

### http 协议

```
定义：超文本传输协议。它不关心寻址、路由、数据完整性等传输细节，而要求这些工作都有下层处理。因为当时流行的 tcp/ip 协议正好满足 http 的需求，所以 http 协议就运行在了 tcp/ip 之上
```

报文：

```
起始行：描述请求或响应的基本信息
头部字段集合：使用 key-value 的形式更详细地说明报文
消息正文：实际传输的数据，可能不是文字，而是图片、音频等二级制数据
请求头和响应头：起始行 + 头部字段集合
实体：消息正文
body：消息正文（与header对应）
请求行：请求报文的起始行。它包括：请求方法、请求目标、版本号
状态行：响应报文的起始行。它包括：版本号、状态码、原因
```

头部通用字段：Cache-Control

```
public: 表示客户端和代理服务器都可以缓存
private：表示只有客户端可以缓存，默认值
no-cache: 表示使用协商缓存来决定
no-store: 表示既不使用强制缓存，也不使用协商缓存
max-age=xxx：缓存内容将在xxx秒后失效
```

头部通用字段：Connection

```
1.Connection: 不再转发的首部字段名
2.Connection: close。因为 http1.1 默认都是持久连接，所以可以用这个字段断开连接
3.Connection: keep-alive。持久连接
```

头部通用字段：Date

```
定义：表明创建 http 报文的日期和时间
```

头部通用字段：Upgrade

```
用途：用来检测 http 协议或其它协议是否可用更高的版本进行通信
```

头部请求字段：Host

```
用途：告知服务器，请求的资源所处的互联网主机名和端口号。它是 http1.1 唯一一个必须被包含在请求内的首部字段
```

头部请求字段：Accept

```
用途：告知服务器，用户代理能够处理的媒体类型和优先级
```

头部请求字段：Accept-Charset

```
用途：告知服务器，用户代理能够支持的字符集和优先级
```

头部请求字段：Accept-Encoding

```
用途：告知服务器，用户代理能够支持的内容编码和优先级

gzip：由 gzip 生成的编码格式
compress：由 UNIX 文件压缩程序 compress 生成的编码格式
deflate：组合使用 zlib 格式并有 deflate 算法生成的编码格式
identity: 不执行压缩或不会变化的默认编码格式
```

头部请求字段：Accept-Language

```
用途：告知服务器，用户代理能够支持的自然语言集和优先级
```

头部请求字段：Authorization

```
用途：告知服务器，用户代理的认证信息
```

头部请求字段：If-Modified-Since

```
用途：用于确认资源的更新时间，如果资源发生了更新，服务器会接受请求；如果资源没有发生更新，服务器会返回状态码 304 Not Modified 的响应，浏览器使用本地缓存
```

头部请求字段：If-None-Match

```
用途：用于检查 ETag，如果不一致时，服务器会接受请求；如果一致则返回状态码 304 Not Modified 的响应，浏览器使用本地缓存
```

头部请求字段：Referer

```
用途：告知服务器，请求的原始资源的 uri
```

头部响应字段：Age

```
用途：告知客户端，实体从产生到现在经过多长时间
```

头部响应字段：ETag

```
用途：将资源以字符串形式做唯一性标识的方式
```

头部响应字段：Location

```
用途：配合 3xx 可以将接收方引导至另一个资源
```

实体字段：Content-Type

```
用途：说明实体内对象的数据类型
```

实体字段：Allow

```
用途：用于通知客户端支持的所有 http 方法，当服务器收到不支持的方法时，会以状态码 405 Method Not Allowed 作为响应返回
```

实体字段：Content-Encoding

```
用途：告知客户端实体主体部分选用的内容编码方式，内容编码是指在不丢失实体信息的前提下所进行的压缩
```

实体字段：Content-Language

```
用途：告知客户端实体主体部分选用的自然语言
```

实体字段：Content-Length

```
用途：告知客户端实体主体部分的大小
```

实体字段：Expires

```
用途：告知客户端资源失效的日期
```

实体字段：Set-Cookie

```
expires: cookie 的有效期
path: cookie 的文件路径
domain: cookie 的域名
secure: 限制仅在 https 的情况下才发送 cookie
HttpOnly: 限制 js 能否获取 cookie
```

队头阻塞：

```
定义：由于http长连接是一个请求一个应答交替进行的，所以如果前面的请求-应答会阻塞后面的请求-应答，即使后面的请求-应答数据量很少。

解决方法：并发连接（浏览器支持并发多个连接，但同一域名下的并发连接有数量限制）、域名分片（把资源的域名分为多个二级域名，指向原本的同一资源，这样就避免了同一域名的并发连接数量）、http2（多路复用）
```

什么是 http:

```
定义：http全称超文本传输协议，它是基于 tcp 协议上的应用层协议，定义了数据传输和连接方式的规范。
组成：它由起始行、头部和实体组成
起始行：起始行有http版本、状态码和原因组成
头部：头部有各种首部字段，主要有请求首部、响应首部、实体首部、cookie首部和其它首部
实体：一般是数据

请求首部：描述能接受什么文件（accept、accept-charset、accept-encoding、accept-language），鉴权信息（authorization），缓存情况（if-modified-since、if-none-match），其它信息（host、referer、user-agent）
响应首部：描述服务器的信息（age、server、location）
实体首部：allow、content-encoding、content-type、content-language、content-length、last-modified、etag
cookie首部：set-cookie、cookie
其它首部：x-
```

### 响应状态码

1xx:

```
定义：表示目前是协议处理的中间状态，还需要后续的操作

101：表示客户端正在使用 Upgrade 字段改变协议
```

2xx:

```
定义：表示成功，报文已收到并被正确处理

200：OK，表示一切正常
204：No Content，表示一切正常，但是后面没有 body 数据
206：Partial Content，表示范围请求，是断点续传的基础
```

3xx:

```
定义：重定向，资源位置发生变动，需要客户端重新发送请求

301：Moved Permanently，永久重定向，请求的资源不存在，需要用新的 uri 访问。比如网站升级到了 https，以前的 http 不再使用了，就需要使用 301 跳转
302：Found，临时重定向，表示请求的资源还在，但需要暂时用另一个 uri 访问。比如夜里网站后台需要维护，服务暂不可用，就可以配置 302 跳转，此时浏览器不会做缓存优化，第二天还会访问原来的地址。
304：Not Modified，表示资源未修改，用于缓存控制，通常不会进行跳转，但是可以理解成重定向到已经缓存的文件
```

4xx:

```
定义：客户端错误，请求报文有误，服务器无法处理

400：Bad Request，表示请求报文有误，是一个笼统的错误，客户端一头雾水。在开发时应尽量使用有其它明确意思的状态码。
403：Forbidden，表示服务器禁止访问资源
404：Not Found，表示资源在本服务器上未找到
405：Method Not Allowed，表示不允许使用某些方法操作资源
406：Not Acceptable，表示资源无法满足客户端请求的条件，比如请求中文但是只有英文
408：Request Timeout，表示请求超时
409：Conflict，表示多个请求发生了冲突
413：Request Entity Too Large，表示请求报文的 body 太大了
414：Request URI Too Large，表示请求行里的 uri 太大了
429：Too Many Request，客户端发送了太多的请求
431：Request Header Fields Too Large，请求头某个字段太大了
```

5xx:

```
定义：服务器错误，服务器在处理请求时内部发生了错误

500：Internal Server Error，通用的服务器错误，没有告知原因
501：Not Implemented，表示客户端请求的功能还不支持，意思是即将开业，敬请期待
502：Bad Gateway，表示网关或代理服务器工作正常，但是访问后端服务器发生了错误
503：Service Unavailable，表示服务器当前很忙，暂时无法响应服务
```

### 安全和幂等

```
安全：指请求方法不会破坏服务器上的资源。只读操作的 GET 和 HEAD 方法是安全的。

幂等：指多次执行相同的操作，结果也是相同的。GET 和 HEAD 显然是幂等的，DELETE 多次删除同一个资源，会提示资源不存在，所以也是幂等的，PUT 多次更新一个资源，结果还是第一个更新的资源，所以也是幂等的，POST 多次提交新数据会创建多个资源，所以不是幂等的
```

### 并发与域名分片

```
原理：浏览器对每个域名的并发请求数有数量限制，一般是6个，所以域名分片是指，把单个域名分拆成多个域名，然后指向同一个服务器。

缺点：已过时，现在被 http2.0 所取代
```

### 一个 http 请求的全周期

```
1.DNS 解析：得出 ip 地址
2.HTTP：生成请求报文
3.TCP：将请求报文分成多个报文段，确保报文段准确送到。使用三次握手确保连接可靠
4.ip地址：节点被分配的地址（ip地址：节点被分配的地址；MAC地址：网卡所属的固定地址），一边中转一边传动
5.TCP：重组报文
6.HTTP：对请求进行处理
```

### DNS 协议

```
DNS 查询：由于 DNS 数据包不大，并且只需要一个请求，一个应答就好了，所以 DNS 协议一般使用 UDP 协议就好了，除非当数据长度大于 512 字节时，才会使用 tcp 协议。

非权威域名服务器：许多大公司会建立自己的 DNS 服务器，代理用户访问核心 DNS 系统。

DNS的查询顺序：浏览器 DNS 缓存，操作系统 DNS 缓存，Hosts 文件，非权威域名服务器，根域名服务器，顶级域名服务器，权威域名服务器

DNS 查询的应用场景：负载均衡、域名屏蔽、域名劫持
```

### IP 协议

```
目的：主要解决寻址和路由问题，以及如何在两点传输数据包。对比现实中的电话系统。
特点：提供可靠的（数据不丢失）、字节流形式（保证数据完整）的通信
```

### TCP 协议

```
定义：面向连接的、可靠的字节流服务

三次握手：首先客户端发送一个 syn 的tcp 包，表示请求应答；服务端接受这个 tcp 包之后回传一个 syn 和 ack 的 tcp 包，表示确认应答；客户端接受这个 tcp 包之后再发送一个 syc + 1 和 ack 的 tcp 包，表示确认连接。

为什么要用三次：防止失效的连接请求耗费服务器资源的情况

四次挥手：首先客户端说自己已经没有数据要发送了，但是仍然可以接受数据；然后服务器回复收到了，准备关闭请求，但是还没有准备好；然后服务器准备好了之后就对客户端说已经准备好了；客户端收到后，回复可以关闭了，然后服务器接收到之后就会关闭请求，而客户端这边等待一会儿之后如果没有再收到数据才会关闭。

为什么要四次挥手：因为客户端不再发送数据的时候可能还需要接受数据

tcp/ip 协议族：ip协议、tcp协议以及基于它们的其他协议比如udp协议、dns协议等
```

### http 安全

xss 跨站脚本攻击：

```
本质：攻击者提交恶意代码，浏览器执行恶意代码

反射型：恶意 js 脚本是用户自己发送给网站的（通常被带在链接里面），然后网站又把恶意 js 脚本返回给用户进行执行，这个时候 js 脚本就会做一些恶意操作。比如：http://localhost:3000/?xss=<script>alert('你被xss攻击了')</script>

储存型：恶意 js 脚本被上传到服务器，通过服务器发送给用户。比如论坛系统的恶意代码

DOM型：通过修改 Web 页面的数据，把恶意代码注入到 html 里面，从而在用户打开页面的时候执行恶意操作。比如 wifi 路由器劫持、本地恶意软件劫持等。

应对策略：输入过滤、转义、限制输入长度、使用验证码等。

CSP网页安全策略：本质是白名单，明确告诉浏览器，哪些资源可以加在，开发者可以通过 meta 标签添加。比如：<meta http-equiv="Content-Security-Policy" content="script-src 'self'; object-src 'none'; style-src cdn.example.org third-party.org; child-src https:">
```

csrf 跨站请求伪造：

```
概念：诱导用户在登录状态下打开其它网站，此时就可以利用用户目前的登录状态发起跨站请求

特点：主要发生在第三域名；攻击者不能获取 cookie，但能使用

应对策略：使用白名单阻止不明外域的访问（referer等）；请求上添加只有本域才能获得的 csrf token；验证码；转账前输入密码

SameSite：cookie 有一个 SameSite 属性，它能够禁止第三方请求携带cookie

简单检测网站是否存在 csrf 漏洞的方法：抓取一个正常请求的数据包，去掉 Referer 字段后再重新提交，如果该提交还有效，那么基本上可以确定存在CSRF漏洞。
```

### restful api

put 和 patch 的区别：

```
put是使用实体去替换全部信息，patch是包含一个指令，用这个指令更新部分信息。所以put是幂等的，patch不是幂等的。
```

### oauth2.0

Oauth2.0 是目前最流行的授权机制，用来授权第三方应用，获取用户数据：

```
1.第三方应用申请应用id。
2.用户使用应用id跑去授权服务器请求授权
3.用户在授权服务器登录并且同意授权之后，授权服务器返回access token
4.用户把这个access token传给资源服务器
5.资源服务器使用access token和应用id向授权服务器验证，成功之后返回资源（登录token）
```

基于 jwt 和 session 进行用户认证的优缺点：

```
jwt: 无状态，不需要储存在服务端，性能好。但是解密简单，不能保存隐秘信息，载荷会很长，并且需要一个过期时间和黑名单。
session: 有状态，需要redis储存和查询，但是框架自带容易部署
```
