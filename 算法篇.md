## 算法篇

### 基础

各种数据类型：

```
数组：数组支持高效的读和写操作，但是在插入和删除操作的时候性能很低
链表：为了解决数组插入和删除低效的问题，出现了链表，但是链表的读操作性能很低
栈：一种先入后出的数据结构，可以用数组或链表实现
队列：一种先入先出的数据结构，可以用数组或链表实现
优先队列：一种正常进，但是按照优先级出的数据结构
树：树是一种有多个next节点的特殊的链表
二叉树：二叉树是最多只有2个子节点的树
二叉搜索树：左子树上的所有节点都小于右子树上的所有节点
图：图是一种能够指回父节点的树
```

十大排序算法：冒泡排序、选择排序、插入排序、希尔排序、归并排序、快速排序、堆排序、计数排序、桶排序、基数排序。

冒泡排序：遍历数据，每次遍历比较相邻元素的大小，把小的放前面，直到没有操作为止

选择排序：遍历数据，每次选择最小的那个拿出来放入另一个数组

插入排序：从左到右遍历，每次把元素插入到左边合适的位置

归并排序：每次二等分，然后分别排序，递归，最后归并

快速排序：调出一个基准，把大于和小于它的数分成2份，递归，然后归并

### 代码模板

```js
// 递归
function recursion(level, param1, param2, ...) {
    // terminator
    if (level > MAX_LEVEL) {
        return result;
    }

    // process data
    processData(level, data...)

    // drill down
    recursion(level + 1, p1, p2, ...)

    // other process if needed
    reverseState(level)
}

// 分治
function divide(problem, param1, param2, ...) {
    // terminator
    if (problem === null) {
        return result;
    }

    // prepare data
    data = prepareData(problem);
    subProblems = splitProblem(problem, data);

    // process sub-problems
    subResult1 = divide(subProblems[0], p1, ...)
    subResult2 = divide(subProblems[1], p2, ...)
    subResult3 = divide(subProblems[2], p3, ...)
    ...

    // generate final result
    result = processResult(subResult1, subResult2, subResult3)
}

// bfs
function bfs(tree) {
    const queue = [tree.root]

    while(queue.length > 0) {
        const node = queue.shift()

        // process node
        process(node)

        queue.push(node.children)
    }
}

// dfs
function dfs(tree) {
    const stack = [tree.root]

    while(stack.length > 0) {
        const node = stack.pop()

        // process node
        process(node)

        stack.push(node.children)
    }
}

function dfsRecursion(tree) {
    // process node
    process(node)

    node.children.forEach(child => dfsRecursion(child))
}

// 二分
function binarySearch(array, target) {
    const left = 0
    const right = array.length - 1

    while(left <= right) {
        const mid = (left + right) / 2

        if (array[mid] === target) {
            return mid
        } else if (array[mid] < target) {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
}

// 前序遍历
function preOrder(root, arr) {
    if (root == null) {
        return;
    }

    arr.push(root.val);
    preOrder(root.left, arr);
    preOrder(root.right, arr);
}

// 中序遍历
function midOrder(tree) {
    if (root == null) {
        return;
    }

    midOrder(root.left, arr);
    arr.push(root.val);
    midOrder(root.right, arr);
}

// 后序遍历
function afterOrder(tree) {
    if (root == null) {
        return;
    }

    preOrder(root.left, arr);
    preOrder(root.right, arr);
    arr.push(root.val);
}
```

### 快速排序

```js
function quickSort(arr, left, right) {
  if (left < right) {
    const pos = partition(arr, left, right)
    quickSort(arr, left, pos - 1)
    quickSort(arr, pos + 1, right)
  }
  return arr
}

/**
 * 找出分界点，使它左边的数都小于它，右边的数都大于等于它
 */
function partition(arr, left, right) {
  const pivot = arr[right]
  let j = left
  for (let i = left; i < right; i += 1) {
    if (arr[i] < pivot) {
      swap(arr, i, j)
      j += 1
    }
  }
  swap(arr, j, right)
  return j
}

/**
 * 交换i和j的值
 */
function swap(arr, i, j) {
  const temp = arr[i]
  arr[i] = arr[j]
  arr[j] = temp
}
```

### 插入排序

```js
function insertSort(arr) {
  const len = arr.length
  for (let i = 1; i < len; i += 1) {
    const pivot = arr[i]

    let j = i - 1
    while (j >= 0 && arr[j] > pivot) {
      arr[j + 1] = arr[j]
      j -= 1
    }

    arr[j + 1] = pivot
  }
  return arr
}
```

### 最大堆（数组形式）

```js
class MaxHeap {
  constructor(arr) {
    // arr[0]不使用，从1开始存
    this.arr = [null]
    this.len = 0

    for (let i = 0; i < arr.length; i += 1) {
      this.insert(arr[i])
    }
  }

  insert(num) {
    this.len += 1
    const { arr, len } = this
    arr[len] = num
    this.swim(len)
  }

  delMax() {
    const { arr, len } = this
    const res = arr[1]
    this.swap(1, len)
    arr[len] = null
    this.sink(1)
    return res
  }

  sink(k) {
    const { arr, len } = this
    while (2 * k <= len) {
      let child = 2 * k
      if ((child + 1) <= len && arr[child] < arr[child + 1]) {
        child += 1
      }

      if (arr[k] >= arr[child]) {
        break
      }

      this.swap(k, child)
      k = child
    }
  }

  swim(k) {
    const { arr } = this
    while(k > 1) {
      let parent = k >> 1
      if (arr[parent] > arr[k]) {
        break
      }
      this.swap(k, parent)
      k = parent
    }
  }

  swap(i, j) {
    const temp = this.arr[i]
    this.arr[i] = this.arr[j]
    this.arr[j] = temp
  }
}
```

### 最小/小堆（数组形式）

```ts
class Heap<T = number> {
  arr: (T | null)[]
  len: number
  compare: Function

  constructor(arr: T[] | Function | string = [], type: string | Function = 'max') {
    // arr[0]不使用，从1开始存
    this.arr = [null]
    this.len = 0

    // 兼容第一个参数
    if (typeof arr === 'string' || typeof arr === 'function') {
      type = arr
      arr = []
    }

    this.compare = typeof type === 'function'
      ? this.wrapCompare(type)
      : type === 'max' ? this.maxCompare : this.minCompare

    for (let i = 0; i < arr.length; i += 1) {
      this.insert(arr[i])
    }
  }

  maxCompare(i: number, j: number) {
    return i < j
  }

  minCompare(i: number, j: number) {
    return i > j
  }

  wrapCompare(compare: Function) {
    return (i, j) => compare(i, j) > 0
  }

  insert(num: T) {
    this.len += 1
    const { arr, len } = this
    arr[len] = num
    this.swim(len)
  }

  top() {
    return this.arr[1]
  }

  size() {
    return this.len
  }

  delTop() {
    const { arr, len } = this
    const res = arr[1]
    this.swap(1, len)
    arr[len] = null
    this.len -= 1
    this.sink(1)
    return res
  }

  sink(k: number) {
    const { arr, len } = this
    while (2 * k <= len) {
      let child = 2 * k
      if (child + 1 <= len && this.compare(arr[child], arr[child + 1])) {
        child += 1
      }

      if (this.compare(arr[child], arr[k])) {
        break
      }

      this.swap(k, child)
      k = child
    }
  }

  swim(k: number) {
    const { arr } = this
    while (k > 1) {
      let parent = k >> 1
      if (this.compare(arr[k], arr[parent])) {
        break
      }
      this.swap(k, parent)
      k = parent
    }
  }

  swap(i: number, j: number) {
    const temp = this.arr[i]
    this.arr[i] = this.arr[j]
    this.arr[j] = temp
  }
}
```

### 区间查询（分段）

```ts
// 307. 区域和检索 - 数组可修改
// 执行用时 720 ms，内存消耗：74.7 MB
class NumArray {
  block: number
  list: number[]
  nums: number[]
  constructor(nums: number[]) {
    const block = Math.floor(Math.sqrt(nums.length))
    const list = Array(block + 1).fill(0)
    const len = nums.length

    for (let i = 0; i < len; i += 1) {
      list[Math.floor(i / block)] += nums[i]
    }

    this.block = block
    this.list = list
    this.nums = nums
  }

  update(index: number, val: number): void {
    this.list[Math.floor(index / this.block)] += val - this.nums[index]
    this.nums[index] = val
  }

  sumRange(left: number, right: number): number {
    const { nums, list, block } = this
    let l = left
    let res = 0
    while (l <= right) {
      if ((l % block === 0) && (l + block <= right)) {
        res += list[Math.floor(l / block)]
        l += block
      } else {
        res += nums[l]
        l += 1
      }
    }
    return res
  }
}
```

### 区间查询（分段前缀和）

```ts
// 307. 区域和检索 - 数组可修改
// 执行用时 744 ms，内存消耗：74 MB
class NumArray {
  block: number
  list: number[][]
  constructor(nums: number[]) {
    const block = Math.floor(Math.sqrt(nums.length))
    const list = []
    const len = nums.length

    let arr = []
    let accu = 0
    for (let i = 0; i < len; i += 1) {
      accu += nums[i]
      arr.push(accu)
      if ((i + 1) % block === 0 || i === len - 1) {
        list.push(arr)
        arr = []
        accu = 0
      }
    }

    this.block = block
    this.list = list
  }

  update(index: number, val: number): void {
    const { list, block } = this
    const blockNum = Math.floor(index / block)
    const blockList = list[blockNum]
    const start = index % block
    const diff = start % block === 0 ? (val - blockList[start]) : (val - blockList[start] + blockList[start - 1])
    for (let i = start; i < blockList.length; i += 1) {
      blockList[i] += diff
    }
  }

  sumRange(left: number, right: number): number {
    const { list, block } = this
    const blockNumLeft = Math.floor(left / block)
    const blockLeft = list[blockNumLeft]
    const blockLeftStart = left % block
    const blockNumRight = Math.floor(right / block)
    const blockRight = list[blockNumRight]
    const blockRightStart = right % block
    let res = 0
    for (let i = blockNumLeft; i < blockNumRight; i += 1) {
      const blockList = list[i]
      res += blockList[blockList.length - 1]
    }
    if (blockLeftStart !== 0) {
      res -= blockLeft[blockLeftStart - 1]
    }
    res += blockRight[blockRightStart]
    return res
  }
}
```

### 区间查询（树状数组）

```ts
// 307. 区域和检索 - 数组可修改
// 执行用时 528 ms，内存消耗：74 MB
class NumArray {
  block: number
  list: number[][]
  constructor(nums: number[]) {
    const block = Math.floor(Math.sqrt(nums.length))
    const list = []
    const len = nums.length

    let arr = []
    let accu = 0
    for (let i = 0; i < len; i += 1) {
      accu += nums[i]
      arr.push(accu)
      if ((i + 1) % block === 0 || i === len - 1) {
        list.push(arr)
        arr = []
        accu = 0
      }
    }

    this.block = block
    this.list = list
  }

  update(index: number, val: number): void {
    const { list, block } = this
    const blockNum = Math.floor(index / block)
    const blockList = list[blockNum]
    const start = index % block
    const diff = start % block === 0 ? (val - blockList[start]) : (val - blockList[start] + blockList[start - 1])
    for (let i = start; i < blockList.length; i += 1) {
      blockList[i] += diff
    }
  }

  sumRange(left: number, right: number): number {
    const { list, block } = this
    const blockNumLeft = Math.floor(left / block)
    const blockLeft = list[blockNumLeft]
    const blockLeftStart = left % block
    const blockNumRight = Math.floor(right / block)
    const blockRight = list[blockNumRight]
    const blockRightStart = right % block
    let res = 0
    for (let i = blockNumLeft; i < blockNumRight; i += 1) {
      const blockList = list[i]
      res += blockList[blockList.length - 1]
    }
    if (blockLeftStart !== 0) {
      res -= blockLeft[blockLeftStart - 1]
    }
    res += blockRight[blockRightStart]
    return res
  }
}
```

### 区间查询（数组形式的线段树（自底向上建树））

```ts
// 307. 区域和检索 - 数组可修改
// 执行用时 548 ms，内存消耗：75.5 MB
class NumArray {
  n: number
  st: number[]
  constructor(nums: number[]) {
    const n = nums.length
    const st = Array(n * 2).fill(0)
    for (let i = n; i < n * 2; i += 1) {
      st[i] = nums[i - n]
    }
    for (let i = n - 1; i >= 0; i -= 1) {
      st[i] = st[i << 1] + st[(i << 1) | 1]
    }
    this.n = n
    this.st = st
  }

  update(index: number, val: number): void {
    const { n, st } = this
    let l = n + index
    st[l] = val
    while (l > 0) {
      st[l >> 1] = st[l] + st[l ^ 1]
      l >>= 1
    }
  }

  sumRange(left: number, right: number): number {
    const { n, st } = this
    let l = n + left
    let r = n + right
    let res = 0
    while (l <= r) {
      if (l & 1) {
        res += st[l++]
      }
      if (!(r & 1)) {
        res += st[r--]
      }
      l >>= 1
      r >>= 1
    }
    return res
  }
}
```

### 区间查询（map形式的线段树（自顶向下建树，无懒标记））

```ts
// 307. 区域和检索 - 数组可修改
// 执行用时 904 ms，内存消耗：76.5 MB
class NumArray {
  n: number
  st: Map<number, number>
  constructor(nums: number[]) {
    const n = nums.length
    this.n = n
    this.st = new Map()
    this.build(1, 0, n)

    for (let i = 0; i < n; i += 1) {
      this.update(i, nums[i])
    }
  }

  build(index: number, l: number, r: number) {
    this.st.set(index, 0)
    if (l < r) {
      const mid = l + r >> 1
      this.build(index * 2, l, mid)
      this.build(index * 2 + 1, mid + 1, r)
    }
  }

  // 单点修改
  updateSt(l: number, r: number, index: number, id: number, val: number) {
    if (l === r && l === index) {
      this.st.set(id, val)
      this.pushUp(id)
    } else {
      const mid = l + r >> 1
      if (index <= mid) {
        this.updateSt(l, mid, index, id * 2, val)
      } else {
        this.updateSt(mid + 1, r, index, id * 2 + 1, val)
      }
    }
  }

  // 更新父节点
  pushUp(id: number) {
    const { st } = this
    let l = id >> 1
    while (l > 0) {
      const leftChild = st.get(l * 2) || 0
      const rightChild = st.get((l * 2 + 1) | 1) || 0
      st.set(l, leftChild + rightChild)
      l >>= 1
    }
  }

  query(l: number, r: number, id: number, start: number, end: number) {
    if (l > end || r < start) {
      return 0
    }
    if (l >= start && r <= end) {
      return this.st.get(id) || 0
    }
    const mid = l + r >> 1
    let res = 0
    res += this.query(l, mid, id * 2, start, end)
    res += this.query(mid + 1, r, id * 2 + 1, start, end)
    return res
  }

  update(index: number, val: number): void {
    this.updateSt(0, this.n, index, 1, val)
  }

  sumRange(left: number, right: number): number {
    return this.query(0, this.n, 1, left, right)
  }
}
```

### 区间查询（map形式的线段树（自顶向下建树，带懒标记））
