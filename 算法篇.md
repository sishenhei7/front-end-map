## 算法篇

### 基础

各种数据类型：

```
数组：数组支持高效的读和写操作，但是在插入和删除操作的时候性能很低
链表：为了解决数组插入和删除低效的问题，出现了链表，但是链表的读操作性能很低
栈：一种先入后出的数据结构，可以用数组或链表实现
队列：一种先入先出的数据结构，可以用数组或链表实现
优先队列：一种正常进，但是按照优先级出的数据结构
树：树是一种有多个next节点的特殊的链表
二叉树：二叉树是最多只有2个子节点的树
二叉搜索树：左子树上的所有节点都小于右子树上的所有节点
图：图是一种能够指回父节点的树
```

十大排序算法：冒泡排序、选择排序、插入排序、希尔排序、归并排序、快速排序、堆排序、计数排序、桶排序、基数排序。

冒泡排序：遍历数据，每次遍历比较相邻元素的大小，把小的放前面，直到没有操作为止

选择排序：遍历数据，每次选择最小的那个拿出来放入另一个数组

插入排序：从左到右遍历，每次把元素插入到左边合适的位置

归并排序：每次二等分，然后分别排序，递归，最后归并

快速排序：调出一个基准，把大于和小于它的数分成2份，递归，然后归并

### 代码模板

```js
// 递归
function recursion(level, param1, param2, ...) {
    // terminator
    if (level > MAX_LEVEL) {
        return result;
    }

    // process data
    processData(level, data...)

    // drill down
    recursion(level + 1, p1, p2, ...)

    // other process if needed
    reverseState(level)
}

// 分治
function divide(problem, param1, param2, ...) {
    // terminator
    if (problem === null) {
        return result;
    }

    // prepare data
    data = prepareData(problem);
    subProblems = splitProblem(problem, data);

    // process sub-problems
    subResult1 = divide(subProblems[0], p1, ...)
    subResult2 = divide(subProblems[1], p2, ...)
    subResult3 = divide(subProblems[2], p3, ...)
    ...

    // generate final result
    result = processResult(subResult1, subResult2, subResult3)
}

// bfs
function bfs(tree) {
    const queue = [tree.root]

    while(queue.length > 0) {
        const node = queue.shift()

        // process node
        process(node)

        queue.push(node.children)
    }
}

// dfs
function dfs(tree) {
    const stack = [tree.root]

    while(stack.length > 0) {
        const node = stack.pop()

        // process node
        process(node)

        stack.push(node.children)
    }
}

function dfsRecursion(tree) {
    // process node
    process(node)

    node.children.forEach(child => dfsRecursion(child))
}

// 二分
function binarySearch(array, target) {
    const left = 0
    const right = array.length - 1

    while(left <= right) {
        const mid = (left + right) / 2

        if (array[mid] === target) {
            return mid
        } else if (array[mid] < target) {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
}

// 前序遍历
function preOrder(root, arr) {
    if (root == null) {
        return;
    }

    arr.push(root.val);
    preOrder(root.left, arr);
    preOrder(root.right, arr);
}

// 中序遍历
function midOrder(tree) {
    if (root == null) {
        return;
    }

    midOrder(root.left, arr);
    arr.push(root.val);
    midOrder(root.right, arr);
}

// 后序遍历
function afterOrder(tree) {
    if (root == null) {
        return;
    }

    preOrder(root.left, arr);
    preOrder(root.right, arr);
    arr.push(root.val);
}
```

### 快速排序

```js
function quickSort(arr, left, right) {
  if (left < right) {
    const pos = partition(arr, left, right)
    quickSort(arr, left, pos - 1)
    quickSort(arr, pos + 1, right)
  }
  return arr
}

/**
 * 找出分界点，使它左边的数都小于它，右边的数都大于等于它
 */
function partition(arr, left, right) {
  const pivot = arr[right]
  let j = left
  for (let i = left; i < right; i += 1) {
    if (arr[i] < pivot) {
      swap(arr, i, j)
      j += 1
    }
  }
  swap(arr, j, right)
  return j
}

/**
 * 交换i和j的值
 */
function swap(arr, i, j) {
  const temp = arr[i]
  arr[i] = arr[j]
  arr[j] = temp
}
```

### 插入排序

```js
function insertSort(arr) {
  const len = arr.length
  for (let i = 1; i < len; i += 1) {
    const pivot = arr[i]

    let j = i - 1
    while (j >= 0 && arr[j] > pivot) {
      arr[j + 1] = arr[j]
      j -= 1
    }

    arr[j + 1] = pivot
  }
  return arr
}
```

### 最大堆（数组形式）

```js
class MaxHeap {
  constructor(arr) {
    // arr[0]不使用，从1开始存
    this.arr = [null]
    this.len = 0

    for (let i = 0; i < arr.length; i += 1) {
      this.insert(arr[i])
    }
  }

  insert(num) {
    this.len += 1
    const { arr, len } = this
    arr[len] = num
    this.swim(len)
  }

  delMax() {
    const { arr, len } = this
    const res = arr[1]
    this.swap(1, len)
    arr[len] = null
    this.sink(1)
    return res
  }

  sink(k) {
    const { arr, len } = this
    while (2 * k <= len) {
      let child = 2 * k
      if ((child + 1) <= len && arr[child] < arr[child + 1]) {
        child += 1
      }

      if (arr[k] >= arr[child]) {
        break
      }

      this.swap(k, child)
      k = child
    }
  }

  swim(k) {
    const { arr } = this
    while(k > 1) {
      let parent = k >> 1
      if (arr[parent] > arr[k]) {
        break
      }
      this.swap(k, parent)
      k = parent
    }
  }

  swap(i, j) {
    const temp = this.arr[i]
    this.arr[i] = this.arr[j]
    this.arr[j] = temp
  }
}
```

### 最小/小堆（数组形式）

```ts
class Heap<T = number> {
  arr: T[]
  len: number
  compare: Function

  constructor(arr: T[] | Function = [], type: string | Function = 'max') {
    // arr[0]不使用，从1开始存
    this.arr = [null]
    this.len = 0

    // 兼容第一个参数
    if (typeof arr === 'string' || typeof arr === 'function') {
      type = arr
      arr = []
    }

    this.compare = typeof type === 'function' ? type : type === 'max' ? this.maxCompare : this.minCompare

    for (let i = 0; i < arr.length; i += 1) {
      this.insert(arr[i])
    }
  }

  maxCompare(i: number, j: number) {
    return i < j
  }

  minCompare(i: number, j: number) {
    return i > j
  }

  insert(num: T) {
    this.len += 1
    const { arr, len } = this
    arr[len] = num
    this.swim(len)
  }

  top() {
    return this.arr[1]
  }

  size() {
    return this.len
  }

  delTop() {
    const { arr, len } = this
    const res = arr[1]
    this.swap(1, len)
    arr[len] = null
    this.len -= 1
    this.sink(1)
    return res
  }

  sink(k: number) {
    const { arr, len } = this
    while (2 * k <= len) {
      let child = 2 * k
      if (child + 1 <= len && this.compare(arr[child], arr[child + 1])) {
        child += 1
      }

      if (this.compare(arr[child], arr[k])) {
        break
      }

      this.swap(k, child)
      k = child
    }
  }

  swim(k: number) {
    const { arr } = this
    while (k > 1) {
      let parent = k >> 1
      if (this.compare(arr[k], arr[parent])) {
        break
      }
      this.swap(k, parent)
      k = parent
    }
  }

  swap(i: number, j: number) {
    const temp = this.arr[i]
    this.arr[i] = this.arr[j]
    this.arr[j] = temp
  }
}
```
